{"version":3,"sources":["routes/Detail.js","components/Movie.js","components/Study.js","routes/Home.js","routes/StudyContent.js","App.js","index.js"],"names":["Detail","_useState","useState","_useState2","Object","slicedToArray","loading","setLoading","_useState3","_useState4","movieInfo","setMovieInfo","id","useParams","getMovie","_ref","asyncToGenerator","_regeneratorRuntime","mark","_callee","json","wrap","_context","prev","next","fetch","concat","sent","console","log","data","movie","stop","apply","this","arguments","useEffect","react_default","a","createElement","title","src","large_cover_image","alt","width","height","yt_trailer_code","frameBorder","allow","allowFullScreen","description_full","runtime","rating","year","genres","map","genre","key","Movie","medium_cover_image","summary","react_router_dom","to","length","slice","Study","Home","movieArray","setMovieArray","getMovies","Home_regeneratorRuntime","movies","components_Movie","components_Study","StudyContent","App","react","react_router","path","routes_Detail","routes_Home","routes_StudyContent","ReactDOM","createRoot","document","getElementById","render","src_App"],"mappings":"u9MA4CeA,MAzCf,WAAkB,IAAAC,EACgBC,oBAAS,GADzBC,EAAAC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,GACPK,EADOH,EAAA,GACEI,EADFJ,EAAA,GAAAK,EAEoBN,mBAAS,IAF7BO,EAAAL,OAAAC,EAAA,EAAAD,CAAAI,EAAA,GAEPE,EAFOD,EAAA,GAEIE,EAFJF,EAAA,GAIPG,EAAMC,cAAND,GACDE,EAAQ,eAAAC,EAAAX,OAAAY,EAAA,EAAAZ,CAAAa,IAAAC,KAAG,SAAAC,IAAA,IAAAC,EAAA,OAAAH,IAAAI,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cAAAF,EAAAE,KAAA,EACaC,MAAK,qDAAAC,OAAsDd,IADxE,cAAAU,EAAAE,KAAA,EAAAF,EAAAK,KAC+EP,OAD/E,OACPA,EADOE,EAAAK,KAEbC,QAAQC,IAAIT,GACZb,GAAW,GACXI,EAAaS,EAAKU,KAAKC,OAJV,wBAAAT,EAAAU,SAAAb,MAAH,yBAAAJ,EAAAkB,MAAAC,KAAAC,YAAA,GAUd,OAJAC,oBAAU,WAAMtB,KAAa,IAE7Bc,QAAQC,IAAInB,GAGR2B,EAAAC,EAAAC,cAAA,WACGjC,EAAU+B,EAAAC,EAAAC,cAAA,wBACXF,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAAA,UAAK7B,EAAU8B,OACfH,EAAAC,EAAAC,cAAA,OAAKE,IAAK/B,EAAUgC,kBAAmBC,IAAKjC,EAAU8B,QAEtDH,EAAAC,EAAAC,cAAA,qBACAF,EAAAC,EAAAC,cAAA,UAAQK,MAAM,MAAMC,OAAO,MAAMJ,IAAG,iCAAAf,OAAmChB,EAAUoC,iBAAmBN,MAAO9B,EAAU8B,MAAOO,YAAY,IAAIC,MAAM,2FAA2FC,iBAAe,IAC5PZ,EAAAC,EAAAC,cAAA,SAAI7B,EAAUwC,kBACdb,EAAAC,EAAAC,cAAA,sBAAc7B,EAAUyC,QAAxB,WACAd,EAAAC,EAAAC,cAAA,4BAAoB7B,EAAU0C,QAC9Bf,EAAAC,EAAAC,cAAA,kBAAU7B,EAAU2C,MACpBhB,EAAAC,EAAAC,cAAA,UACK7B,EAAU4C,OAAOC,IAAI,SAAAC,GAAK,OACvBnB,EAAAC,EAAAC,cAAA,MAAIkB,IAAKD,GAAQA,SCJtBE,MAzBf,SAAA3C,GAAiE,IAAjDH,EAAiDG,EAAjDH,GAAI+C,EAA6C5C,EAA7C4C,mBAAoBnB,EAAyBzB,EAAzByB,MAAOoB,EAAkB7C,EAAlB6C,QAASN,EAASvC,EAATuC,OACpD,OAAOjB,EAAAC,EAAAC,cAAA,WACKF,EAAAC,EAAAC,cAAA,WACAF,EAAAC,EAAAC,cAAA,OAAKE,IAAKkB,EAAoBhB,IAAKH,IACnCH,EAAAC,EAAAC,cAAA,UACIF,EAAAC,EAAAC,cAACsB,EAAA,EAAD,CAAMC,GAAE,UAAApC,OAAYd,IACf4B,IAGTH,EAAAC,EAAAC,cAAA,SAAIqB,EAAQG,OAAS,IAAjB,GAAArC,OAA0BkC,EAAQI,MAAM,EAAE,KAA1C,QAAuDJ,GAC3DvB,EAAAC,EAAAC,cAAA,WACKe,EAAOC,IAAI,SAAAC,GAAK,OACjBnB,EAAAC,EAAAC,cAAA,MAAIkB,IAAKD,GAAQA,QCLtBS,MAPf,WACI,OAAO5B,EAAAC,EAAAC,cAAA,WACHF,EAAAC,EAAAC,cAAA,WACAF,EAAAC,EAAAC,cAACsB,EAAA,EAAD,CAAMC,GAAE,UAAR,mEACAzB,EAAAC,EAAAC,cAAA,8xMCqCO2B,MAxCf,WAAgB,IAAAjE,EACgBC,oBAAS,GADzBC,EAAAC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,GACPK,EADOH,EAAA,GACEI,EADFJ,EAAA,GAAAK,EAEsBN,mBAAS,IAF/BO,EAAAL,OAAAC,EAAA,EAAAD,CAAAI,EAAA,GAEP2D,EAFO1D,EAAA,GAEK2D,EAFL3D,EAAA,GAGR4D,EAAS,eAAAtD,EAAAX,OAAAY,EAAA,EAAAZ,CAAAkE,IAAApD,KAAG,SAAAC,IAAA,IAAAC,EAAA,OAAAkD,IAAAjD,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cAAAF,EAAAE,KAAA,EAERC,MAAM,wEAFE,cAAAH,EAAAE,KAAA,EAAAF,EAAAK,KAGdP,OAHc,OACVA,EADUE,EAAAK,KAIhByC,EAAchD,EAAKU,KAAKyC,QACxBhE,GAAW,GALK,wBAAAe,EAAAU,SAAAb,MAAH,yBAAAJ,EAAAkB,MAAAC,KAAAC,YAAA,GAYf,OAJAC,oBAAU,WAAOiC,KAAc,IAK7BhC,EAAAC,EAAAC,cAAA,WACGjC,EAAU+B,EAAAC,EAAAC,cAAA,wBACXF,EAAAC,EAAAC,cAAA,WACG4B,EAAWZ,IAAI,SAACxB,GAAD,OACdM,EAAAC,EAAAC,cAACiC,EAAD,CACEf,IAAK1B,EAAMnB,GACXA,GAAImB,EAAMnB,GACV+C,mBAAoB5B,EAAM4B,mBAC1BnB,MAAOT,EAAMS,MACboB,QAAS7B,EAAM6B,QACfN,OAAQvB,EAAMuB,YAIpBjB,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAACkC,EAAD,SCkBOC,MArCf,WAGI,OAFW7D,cAGPwB,EAAAC,EAAAC,cAAA,WACIF,EAAAC,EAAAC,cAAA,ghBAKAF,EAAAC,EAAAC,cAAA,qyGCQGoC,MAzBf,WACE,OAAOC,EAAA,cAACf,EAAA,EAAD,KACLe,EAAA,cAACC,EAAA,EAAD,KACED,EAAA,cAACC,EAAA,EAAD,CAAOC,KAAK,UACVF,EAAA,kCAGFA,EAAA,cAACC,EAAA,EAAD,CAAOC,KAAK,cACVF,EAAA,cAACG,EAAD,OAGFH,EAAA,cAACC,EAAA,EAAD,CAAOC,KAAK,KACVF,EAAA,cAACI,EAAD,OAGFJ,EAAA,cAACC,EAAA,EAAD,CAAOC,KAAK,UACVF,EAAA,cAACK,EAAD,UCtBKC,IAASC,WAAWC,SAASC,eAAe,SACpDC,OAEDjD,EAAAC,EAAAC,cAACgD,EAAD","file":"static/js/main.3212b0db.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\r\nimport {useParams} from \"react-router-dom\";\r\n\r\nfunction Detail() {\r\n    const [loading, setLoading] = useState(true);\r\n    const [movieInfo, setMovieInfo] = useState({});\r\n\r\n    const {id} = useParams();\r\n    const getMovie = async() => {\r\n        const json = await (await fetch(`https://yts.mx/api/v2/movie_details.json?movie_id=${id}`)).json();\r\n        console.log(json);\r\n        setLoading(false);\r\n        setMovieInfo(json.data.movie);\r\n    }\r\n    useEffect(()=> {getMovie()}, []);\r\n\r\n    console.log(movieInfo);\r\n\r\n    return (\r\n        <div>\r\n          {loading ? <h1>Loading...</h1> : \r\n          <div>\r\n            <h1>{movieInfo.title}</h1>\r\n            <img src={movieInfo.large_cover_image} alt={movieInfo.title}></img>\r\n            \r\n            <h2>Trailer</h2>\r\n            <iframe width=\"789\" height=\"444\" src={`https://www.youtube.com/embed/${movieInfo.yt_trailer_code}`} title={movieInfo.title} frameBorder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowFullScreen></iframe>\r\n            <p>{movieInfo.description_full}</p>\r\n            <p>Run Time: {movieInfo.runtime} minute</p>\r\n            <p>Average Rating: {movieInfo.rating}</p>\r\n            <p>Year: {movieInfo.year}</p>\r\n            <ul>\r\n                {movieInfo.genres.map(genre => \r\n                    <li key={genre}>{genre}</li>)}\r\n            </ul>\r\n\r\n          </div>\r\n          }\r\n        </div>\r\n      )\r\n}\r\n\r\n// 영화 링크 하나하나를 누르면 나오는 화면을 구성해주는 컴포넌트\r\n\r\nexport default Detail;","import React from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport PropTypes from \"prop-types\"\r\n\r\nfunction Movie({id, medium_cover_image, title, summary, genres}) {\r\n    return <div>\r\n                <hr></hr>\r\n                <img src={medium_cover_image} alt={title}></img>\r\n                <h2>\r\n                    <Link to={`/movie/${id}`}>\r\n                        {title}\r\n                    </Link>\r\n                </h2>\r\n                <p>{summary.length > 256 ? `${summary.slice(0,256)}... ` : summary}</p>\r\n                <div>\r\n                    {genres.map(genre => \r\n                    <li key={genre}>{genre}</li>)}\r\n                </div>\r\n            </div>\r\n}\r\n\r\nMovie.propTypes = {\r\n    id:PropTypes.number.isRequired,\r\n    medium_cover_image: PropTypes.string.isRequired,\r\n    title: PropTypes.string.isRequired,\r\n    summary: PropTypes.string.isRequired,\r\n    genres: PropTypes.arrayOf(PropTypes.string).isRequired,\r\n  }\r\n\r\nexport default Movie;\r\n\r\n// home 화면에서 하나하나의 movie 조각들을 그려줄 컴포넌트","import React from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\nimport PropTypes, { func } from \"prop-types\"\r\n\r\nfunction Study() {\r\n    return <div>\r\n        <hr></hr>\r\n        <Link to={`/study`}>추가 공부한 내용들 링크</Link>\r\n        <hr></hr>\r\n    </div>\r\n}\r\nexport default Study;","import React from \"react\";\r\nimport { useState, useEffect } from \"react\";\r\nimport Movie from \"../components/Movie.js\";\r\nimport Study from \"../components/Study.js\";\r\n\r\nfunction Home() {\r\n  const [loading, setLoading] = useState(true);\r\n  const [movieArray, setMovieArray] = useState([]);\r\n  const getMovies = async () => {\r\n    const json = await (\r\n      await fetch(\"https://yts.mx/api/v2/list_movies.json?minimum_rating=9&sort_by=year\")\r\n    ).json();\r\n    setMovieArray(json.data.movies);\r\n    setLoading(false);\r\n  };\r\n\r\n  useEffect(() => {getMovies()}, []);\r\n  // 웬만하면 useEffect 안의 들어갈 함수는 화살표 함수 형태로 정의하자. 안 그러면 create 어쩌구 \r\n  // 에러가 마구 나옴.\r\n\r\n  return (\r\n    <div>\r\n      {loading ? <h1>Loading...</h1> : \r\n      <div>\r\n        {movieArray.map((movie) => \r\n          <Movie \r\n            key={movie.id}\r\n            id={movie.id}\r\n            medium_cover_image={movie.medium_cover_image}\r\n            title={movie.title}\r\n            summary={movie.summary}\r\n            genres={movie.genres}\r\n          />)}\r\n      </div>\r\n      }\r\n      <div>\r\n        <Study></Study>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\n// Home 화면을 구성해주는 컴포넌트\r\n\r\n\r\nexport default Home;\r\n\r\n","import React, { useEffect, useState } from \"react\";\r\nimport {useParams} from \"react-router-dom\";\r\n\r\n\r\n// let fetched = fetch(\"https://jsonplaceholder.typicode.com/posts\")\r\n// .then(function(response) {\r\n//     return response.json(); // then으로 실행한 콜백함수가 다시 promise 객체를 return해주게끔 하면\r\n//     // 다시한번 then을 통해서 promise가 settled (== locked-in == resolved) 된 이후에(그 중에서도 fulfilled 일 경우)\r\n//     // 되었을 때 실행할 수 있는 콜백함수를 또 줄 수 있음. 이게 promise chaining이고 이걸 많이 쓴다.\r\n// })\r\n// .then(function(data) {\r\n//     console.log(data);\r\n// })\r\n// .catch(function(response) {\r\n//     console.log('reason', response);\r\n// })\r\n\r\nfunction StudyContent() {\r\n    const id = useParams();\r\n\r\n    return (\r\n        <div>\r\n            <p>\r\n                콜백함수는, 특정 함수가 \"다른 함수의 입력값으로 전달되어서 호출된다\"라고 하면\r\n                그것을 callback function이라고 한다. 이미 이런 것들은 꽤 많이 쓰고 있는데, \r\n                배열 객체의 map 메소드라거나, filter 메소드가 이에 속한다.\r\n            </p>\r\n            <p>\r\n                동기 VS 비동기는 지겹지? 실행흐름(순서)이 2개가 있는데 하나의 실행흐름만 사용하는게 동기.(Synchronous)\r\n                setTimeout(function, millisecond); 이런 식으로 쓰면 다른 실행흐름에 setTimeout을 넘기고 작동하는데,\r\n                이게 asynchronous(비동기)\r\n                언제 비동기적인 처리를 하느냐? 서버-웹브라우저 통신 등은 언제 끝날지 \"예측하기 어려움\" 이런 예측하기 어려운\r\n                일들을 주로 비동기적으로 처리함. AJAX는 브라우저 새실행 안하고 통신하게 하는 기술로 조금 다른 주제.\r\n                fetch API에서 사용하는 then이 promise(?) \r\n                fetch는 url을 주면 특정값을 return해주는데, return value가 Promise 객체인데\r\n                이 promise 객체는 response 객체를 돌려줌. 맨 처음에는 pending 상태였다가\r\n                fulfilled or rejected 상태가 될 수 있음.(이 상태를 통칭하여 settled된 상태 == locked-in == resolved)\r\n                함수의 return 값이 promise라면 비동기적인 처리를 담당하는 함수일 가능성이 높다.\r\n                이 promise 객체는 두가지 메소드를 갖는데, 하나가 .then()이고 하나는 .catch()임. 이 두 메소드는\r\n                안정된(settled 된 == resolved 된 == locked-in 된) promise에 대해서 처리해서 다시 새로운 \r\n                promise 객체를 return할 수 있음. 그리고 promise 객체는 resolved 되면 Response 객체를\r\n                넘겨줄 수 있다.\r\n                then (callBackFnforfulfilled, callBackFnforRejected)\r\n                이거 또 promise 객체 뱉는다고 했지? 계속해서 사용가능함.\r\n                아무튼 then의 경우 암묵적으로 result라는 파라미터를 첫 번째 파라미터로 넘겨주고, \r\n                (result == response 객체와 동일하다고 보면 됨) \r\n                catch는 reason이라는 파라미터를 첫번째 파라미터로 넘겨줌.\r\n                (reason == response 객체와 동일하다고 보면 됨)\r\n                여기에 .text() 든 .json이든 주면 다시 promise 객체가 튀어나옴.\r\n                이 promise의 역할은 json 텍스트를 js의 데이터타입으로 converting하는 promise인 것임.\r\n            </p>\r\n        </div>\r\n    )\r\n}\r\nexport default StudyContent;","import * as React from \"react\";\nimport {BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\nimport Detail from \"./routes/Detail.js\";\nimport Home from \"./routes/Home.js\";\nimport StudyContent from \"./routes/StudyContent.js\";\n\n\nfunction App() {\n  return <Router>\n    <Switch>\n      <Route path=\"/hello\">\n        <h1>Hello</h1>\n      </Route>\n\n      <Route path=\"/movie/:id\">\n        <Detail />\n      </Route>\n\n      <Route path=\"/\">\n        <Home />\n      </Route>\n\n      <Route path=\"/study\">\n        <StudyContent />\n      </Route>\n\n    </Switch>\n  </Router>;\n  // Switch는 Route를 찾아서, 컴포넌트를 렌더링함.\n  // Route는 page path와 동일함.\n}\n\nexport default App;\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// import { useState, useEffect } from \"react\";\n\n// function App() {\n//   const [loading, setLoading] = useState(true);\n//   const [coinArray, setCoinArray] = useState([]);\n//   const [inputValue, setInputValue] = useState(0);\n//   const [selectedOptionValue, setSelectedOptionValue] = useState(0);\n//   const [selectedOptionName, setSelectedOptionName] = useState(0);\n\n//   const handleInputChange = (event) => setInputValue(event.target.value);\n\n//   const handleOptionChange = (event) => {\n//     console.log(event.target.selectedIndex);\n//     console.log(selectedOptionName);\n//     // 이 부분에서 가져오는 target은 select임. 그리고 select의 value는\n//     // 기본적으로 \"현재 select된 option의 텍스트(?) - 우리눈에 보이는 그거\"를 갖는다.\n//     // 근데 내가 갖고 싶은건 사실 해당 옵션의 텍스트가 아니라 price 뿐이다.\n//     // 그래서 select가 아니라 option 쪽에 vlaue를 따로 설정해두었다.\n//     // 그러면 그때부터 그 값을 가져온다!\n//     // 다만 selected된 옵션의 이름을 갖고 오고 싶었는데, 그건 fail.. 일단 이걸로 끝\n//     // fail인 줄 알았는데, selectedIndex가 있다..!\n//     // selectedIndex의 값을 가져와서 coinArray에서 대조하여 그 id를 다시 selectedOptionId로 세팅하면\n//     setSelectedOptionValue(event.target.value);\n//     setSelectedOptionName(coinArray[event.target.selectedIndex].name);\n//   };\n\n//   useEffect(() => {\n//     fetch(\"https://api.coinpaprika.com/v1/tickers\").\n//     then((response) => response.json()).\n//     then((json) => {\n//       setCoinArray(json); \n//       setLoading(false);\n//       setSelectedOptionValue(json[0].quotes.USD.price);\n//       setSelectedOptionName(json[0].name);\n//     });}\n//       , [])\n// // 기억해라 fetch(api요청 url).then(받은 response로 뭐시기)\n    \n//   return (\n//     <div>\n//       <h1>The Coins! {loading ? \"\" : \"(\" + (coinArray.length) + \")\"}</h1>\n//       {loading ? <strong>Loading...</strong> : \n//         <select\n//         onChange={handleOptionChange}\n//         value={selectedOptionValue}\n//         >\n//           {coinArray.map((coin) => \n//           <option \n//             key={coin[\"id\"]}\n//             value={coin.quotes[\"USD\"].price}>\n//             {coin[\"name\"]} ({coin.symbol}): {(coin.quotes[\"USD\"].price).toFixed(2)} $\n//           </option>)}\n//         </select>\n//       }\n\n//       <hr />\n//       <input \n//         type=\"number\" \n//         placeholder=\"How much dollar do you have?\"\n//         onChange={handleInputChange}\n//         value={inputValue}\n//       />\n      \n//       <p>You have {inputValue} $</p>\n//       <p>So you can buy {inputValue/selectedOptionValue} amount of {selectedOptionName}</p>\n\n//     </div>\n//     // 관건은 어떻게 select box에 접근하냐임.\n//   )\n// }\n// // jsx에서 javascript 함수를 쓰려면 script 가 아니라 {}로 써야한다.\n// // 그냥 script 하고 하면 안되는건가?\n\n// export default App;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n// import { useState, useEffect } from \"react\";\n\n// function App() {\n//   const [inputValue, setInputValue] = useState(\"\");\n//   const [toDoArray, setToDoArray] = useState([]);\n\n//   const handleChange = (event) => setInputValue(event.target.value);\n\n//   // 참고로... 화살표 함수랑 그냥 함수의 차이는 binding 되는 this가 다르다\n//   // 실행 컨텍스트가 다른건데 그냥 그런게 있는갑다...하고 지나가자.\n//   // 설명은 봤지만 와닿지가 않음. arrow function으로 \n//   // const 함수명 = () => {내용} 혹은 \n//   // const 함수명 = () => 내용; 로 쓴다는 것만 이해하자\n//   // The first one has implicit return. In the second one you have to write 'return'\n\n//   const handleSubmit = (event) => {\n//     event.preventDefault();\n//     if (inputValue === \"\") {\n//       return;\n//     } \n//       setToDoArray(currentArray => [inputValue, ...currentArray]);\n//       // 아래 코드랑 역할은 똑같다.\n//       // setToDoArray(function(currentArray) {\n//       //   return [inputValue, ...currentArray]\n//       // })\n//       setInputValue(\"\");\n//   };\n\n//   // setState로 state를 수정할 때, 특히 배열을 수정할 때 주의해라.\n//   // 기본적으로 state에 \"변화\"를 일으키는 것은 허용하지 않음. 아예 해당 값을 다른 값으로 \"교체\"하는 것이\n//   // 허용되는 것으로 지금 내 이해수준에선 받아들여진다.\n//   // state를 수정하는 함수를 쓸 때는 2가지 옵션이 있음.\n//   // 1. setState(값) : 이런 식으로 하면 해당 state를 그냥 값 으로 설정해버린다.\n//   // 2. setState(함수) : 함수를 보낼 때, react.js는 함수의 첫번째 arg로 현재의 state를 보낸다.\n//   // 이 setState함수의 첫 arg에서 받은 state를 갖고 새로운 state를 만들든 계산하든 하는거임.\n  \n//   useEffect(() => console.log(toDoArray)\n//   ,[toDoArray]);\n\n//   return (\n//     <div>\n//       <h1>My To Do List ({toDoArray.length})</h1>\n//       <form onSubmit={handleSubmit}>\n//         <input \n//           onChange={handleChange}\n//           type=\"text\" \n//           placeholder=\"Wirte your to do\" \n//           value={inputValue} />\n\n//         <button>\n//           Add To Do\n//         </button>\n\n//       </form>\n//       <hr />\n//       <ul>\n//         {toDoArray.map((item, index, arr) => <li key={index}>{item}</li>)}\n//       </ul>\n//     </div>\n//     );\n// }\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n// import Button from \"./Button\";\n// import styles from \"./App.module.css\";\n// import { useState, useEffect } from \"react\";\n\n// // function Hello() {\n// //   useEffect(() => {console.log(\"created\");\n// //   return () => console.log(\"destroyed\");}, []);\n// //   return <h1>Hello</h1>\n// // }\n\n// function Hello() {\n//   useEffect(function () {\n//     console.log(\"created\");\n//     return function () {return console.log(\"destroyed\")};\n//   } , []);\n//   return <h1>Hello</h1>\n// }\n\n// // 컴포넌트가 destroyed 될 때 뭔가 할 수 있게 해주는게 clean up function\n// // 뭐 분석 이벤트를 보낸다든가 등. 그냥 애초에 useEffect가 function을 부르는데\n// // 그 안에다가 function을 한번 더 넣어두는 거임. \n// // 익명의 function인데 () => {} 로 하는거나, function () {}로 하는거나 같다.\n\n\n// function App() { \n//   const [counter, setCounter] = useState(0);\n//   const [keyword, setKeyword] = useState(\"\");\n//   const [showing, setShowing] = useState(false);\n//   const handleShowing = () => setShowing(current => !current);\n\n\n  \n//   function handleSearch(event) {\n//     setKeyword(event.target.value);\n//   }\n  \n//   const handleCounter = () => setCounter(current => current + 1);\n\n//   useEffect(() => {\n//     console.log(\"I run only once\");\n//   },[]);\n\n//   useEffect(() => {\n//     if (keyword !== \"\" && keyword.length > 5) {\n//       console.log(`I run when 'keyword' changes`)\n//     };\n//   },[keyword]);\n\n//   useEffect(() => {\n//     console.log(\"I run 'counter' changes\")\n//   },[counter]);\n//   // useEffect를 활용하면 두개의 인자를 받아서 (1) 첫번째 인자는 실행할 함수\n//   // (2) 어디에 dependency를 가져서 변화할 때마다 실행될지 를 세세하게 설정할 수 있다.\n//   // react는 state가 변화할 때 컴포넌트를 재실행시키는게 기본인데, 그걸 세부적으로 조정할 수 있게 되는 것\n\n//   return (\n//     <div>\n//       <input \n//         value={keyword} \n//         onChange={handleSearch} \n//         type=\"text\" \n//         placeholder=\"Search here\">          \n//       </input>\n\n//       <button onClick={handleShowing}>{showing ? \"Hide\" : \"Show\" }</button>\n//       {showing ? <Hello></Hello> : null}\n\n//       <h1 className={styles.title}>Welcome Back to React {counter} times</h1>\n//       <Button onClickProp={handleCounter} textProp=\"click me\"></Button>\n//     </div>\n//   );\n// }\n\n// export default App;","import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  // <React.StrictMode>\n    <App />\n  // </React.StrictMode>\n);\n\n"],"sourceRoot":""}